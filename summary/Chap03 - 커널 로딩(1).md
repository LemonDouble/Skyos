# C++로 나만의 운영체제 만들기 - 커널 로딩(1)

분류: 운영체제
작성일시: 2021/06/27, 20:39

## GRUB

- x86 아키텍쳐는 하위 호환을 위해, 16bit 리얼 모드부터 부팅을 시작해야 함. (1Mb Memory, 20bit 접근부터 부팅 시작해야 함
- GRUB : GNU 프로젝트의 부트로더, 하드웨어에 종속되지 않고 부팅이 가능하도록 도와줌.

    커널 파일 유효성 확인 → 커널 메모리 적재 → 하드웨어 초기화 후 제어권을 커널로 이양

    1. 파일 시스템 직접 접근 기능
    2. 다양한 실행 파일 형식 지원
    3. 비 멀티부팅 운영체제 지원
    4. 메뉴 인터페이스 (부팅 화면)
    5. 다양한 Filesystem 관리
- GRUB을 사용하기 위해선 GRUB 요구 규격을 준수해야 한다.

## 부팅

- GRUB 사용시 전체 부팅 과정
    1. 바이오스가 부팅 장치를 찾고 MBR(Master Boot Record) 읽어옴
    2. MBR에 GRUB Stage 1이 있으며, Stage 1은 1.5나 2를 불러온다.
    3. Stage 1.5는 MBR 다 30kb 영역에 할당되며, Stage 2를 불러온다
    4. Grub Stage 2는 부트 메뉴나 명령 프롬프트를 보여준다
    5. 사용자가 선택한 커널을 메모리에 적재시켜 커널 엔트리를 실행한다.
    - MBR : 저장매체의 첫 번째 섹터, 운영체제 부팅 시 POST(Power On Self-Test) 이후, MBR을 BIOS가 메모리로 읽음. 이후 읽어들인 부트 코드로 제어권이 이양되어 코드가 실행됨.

- Windows의 경우 부팅 과정
    - (사전지식) HDD는 논리적으로 여러 하드 디스크로 나뉠 수 있음 (Partition)

    1. 컴퓨터 부팅 이후 MBR에서 부팅 가능한 논리 하드 디스크를 조회함.
    2. 부팅 가능한 논리 디스크가 있다면, 해당 디스크의 부트섹터를 찾아 메모리로 읽어드리고 메모리로 읽어들인다.
    3. (Windows의 경우) 부트섹터는 Ntldr이라는 커널 로더를 메모리에 적재, 제어권을 Ntldr에 이양한다.
    4. Ntldr은 커널의 코어, 파일시스템 관련 시스템 파일을 로드하여 운영체제를 가동시킨다.
    5. 이후 커널 코어와 파일시스템은 시스템 자원을 확인하기 위해 여러 커널 모듈을 동적/정적으로 로드시켜 운영체제를 실행시킨다.

    - GRUB은 부팅 후 Ntldr의 역할까지 수행한다.

## GRUB이 커널에 넘겨주는 파라미터

- GRUB은 보호 모드로 전환한 후 커널을 Call, 하지만 커널은 하드웨어 관련 정보를 얻기 힘드므로 GRUB은 커널에 구조체 정보를 넘겨줌.
- 해당 구조체 이름은 MultiBootInfo

## 커널 엔트리 찾기

- GRUB이 커널 엔트리 포인트 (커널 시작 지점) 호출 위해서는 커널이 특정 명세를 준수해야 함.
- 커널 파일에서 최초 80KB 부분 검색하여, 특정 Signiture 찾으면 명세를 준수한다고 가정.
- 해당 Signiture을 멀티부트 헤더 구조체라 부름.